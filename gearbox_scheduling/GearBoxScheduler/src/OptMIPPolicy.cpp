/*
 * OptMIPPolicy.cpp
 *
 *  Created on: Jun 1, 2013
 *      Author: lm111
 */

#include "OptMIPPolicy.h"

OptMIPPolicy::OptMIPPolicy() {
	// TODO Auto-generated constructor stub

}

OptMIPPolicy::~OptMIPPolicy() {
	// TODO Auto-generated destructor stub
}

bool OptMIPPolicy::schedule(list<Job>& jobList, map<string, string>& pars) {
	// TODO Admission control: compare the revenue of solutions that accept the new job or not.
	double currentTime = 0.0; // TODO Change to use the current time
	double max = 0.0;
	for (list<Job>::iterator itr = jobList.begin(); itr != jobList.end();
			itr++) {
		double lastDeadline = itr->startTime + itr->pricingFunc->maxX;
		double remain = lastDeadline - currentTime;
		assert(remain > 0.0);
		max = (remain > max) ? remain : max;
	}

	double tSliceLen = atof(pars.find("time_slice_length")->second.c_str());
	IloInt tSliceCount = IloInt(max / tSliceLen);
	//Cristina Patch
	//assert(tSliceCount > 1);
	assert(tSliceCount >= 1);

	IloEnv env;
	try {
		IloModel model(env);
		IloInt jobCount = jobList.size();
		IloInt slotCount = atol(pars.find("slot_count")->second.c_str());
		IloInt j, t;
		IloArray<IloNumVarArray> x(env, jobCount);
		IloArray<IloBoolVarArray> y(env, jobCount);
		IloNumVarArray z(env);
		list<Job>::iterator itr;
		IloInt t_max;

		for (j = 0; j < jobCount; j++) {
			x[j] = IloNumVarArray(env, tSliceCount, 0, slotCount, ILOINT); // Job j has x[j][t] slots at time t.
			y[j] = IloBoolVarArray(env, tSliceCount); // If y[j][t] == 1, job j finishes at time t.
			IloExpr ySum (env);
			for (t = 0; t < tSliceCount; t++)
					ySum += y[j][t];
			model.add(ySum == 1);// Job j only finishes once.

			IloNumVar p(env);
			z.add(p);// z[j] is the profit generated by job j.
		}

		// Each job should finish within the feasible deadline range.
		// Constraint (2) in the hotcloud paper.
		itr = jobList.begin();
		for (j = 0; j < jobCount; j++) {
			// Compute the t_max
			double elapsedTime = currentTime - itr->startTime;
			//Cristina Patch
			//assert(elapsedTime >= -0.0001);
			assert(elapsedTime >= -0.0001 || currentTime==0);
			IloNum maxD = itr->pricingFunc->maxX;
			t_max = IloInt((maxD - elapsedTime) / tSliceLen);
			assert(t_max >= 0);

			IloExpr ySum(env);
			for (t = 0; t < t_max; t++)
				ySum += y[j][t];
			model.add(ySum == IloTrue ); // Job must finish before t_max

			itr++;
		}

		// Once a job is completed, it won't be allocated any slot.
		// Constraint (5) in the hotcloud paper.
		itr = jobList.begin();
		for (j = 0; j < jobCount; j++) {
			double elapsedTime = currentTime - itr->startTime;
			double maxD = itr->pricingFunc->maxX;
			t_max = IloInt((maxD - elapsedTime) / tSliceLen);
			assert(t_max >= 0);
			for (t = 0; t < tSliceCount; t++) {
				IloExpr ySum(env);
				for (IloInt z = t; z < tSliceCount; z++) {
					ySum += y[j][z];
				}
				IloNum K = slotCount;
				model.add(x[j][t] <= K * ySum);
			}
			itr++;
		}

		// Each job must complete the remaining job size.
		// Constraint (3) in the hotcloud paper.
		itr = jobList.begin();
		for (j = 0; j < jobCount; j++) {
			IloNum elapsedTime = currentTime - itr->startTime;
			IloNum maxD = itr->pricingFunc->maxX;
			t_max = IloInt((maxD - elapsedTime) / tSliceLen);
			assert(t_max >= 0);

			IloExpr xaSum(env);
			IloNum jobSize = itr->jobSize;
			for (t = 0; t < t_max; t++)
				xaSum += x[j][t] * tSliceLen;

			IloNum error = atof(pars.find("job_size_error")->second.c_str());
			model.add(xaSum >= jobSize - error);
			model.add(xaSum <= jobSize + error);

			itr++;
		}

		// Within each time slice, the total usage of slots is bounded.
		// Constraint (4) in the hotcloud paper.
		for (t = 0; t < tSliceCount; t++) {
			IloExpr xSum(env);
			for (j = 0; j < jobCount; j++)
				xSum += x[j][t];
			model.add(xSum <= slotCount);
		}

		// Each job's profit is controlled by its pricing function.
		// Constraint (6) in the hotcloud paper.
		itr = jobList.begin();
		for (j = 0; j < jobCount; j++) {
			IloNum elapsedTime = currentTime - itr->startTime;
			IloNum maxD = itr->pricingFunc->maxX;
			t_max = IloInt((maxD - currentTime) / tSliceLen);
			assert(t_max >= 0);

			IloExpr remainTSlices(env);
			for (t = 0; t < t_max; t++)
				remainTSlices += (t+1) * y[j][t];

			IloExpr remainTime(env);
			remainTime = remainTSlices * tSliceLen;
			IloExpr jobTime(env);
			jobTime = elapsedTime + remainTime;

			// Use piecewise function to depict the profit function.
			IloNum minD = itr->pricingFunc->minX;
			IloNum maxPay = itr->pricingFunc->returnY(minD);
			IloNum minPay = itr->pricingFunc->returnY(maxD);
			IloNum slope = (maxPay - minPay) / (minD - maxD);
			assert (slope < 0);

			IloExpr profit(env);
			IloNum step1 = maxPay;
			IloNum step2 = 0.0 - minPay;
			IloNum fakeSlope = -0.01; // Ensure that jobs will be finished as early as possible
			profit = IloPiecewiseLinear(jobTime, IloNumArray(env, 5, 0.0, 0.0, minD, maxD, maxD),
                    IloNumArray(env, 6, 0.0, step1, fakeSlope, slope, step2, 0.0), -1.0, 0.0);

            model.add(z[j] <= profit);
            itr++;
		}

		// State the optimization objective
		IloExpr profitSum(env);
		for (j = 0; j < jobCount; j++)
			profitSum += z[j];
		IloObjective obj = IloMaximize(env, profitSum);
		model.add(obj);

		IloCplex cplex(model);
		IloNum error = atof(pars.find("solution_error")->second.c_str());
        cplex.setParam(IloCplex::EpGap, error);
        IloNum timeLimit = atof(pars.find("computation_time_limit")->second.c_str());
        cplex.setParam(IloCplex::TiLim, timeLimit);
        // Optimize the problem and obtain solution.
        cout << "\nBasic info about the optimiztaion: " << endl;
        cout << "#jobs: " << jobCount << endl;
        cout << "#time slices: " << tSliceCount << endl;
        cout << "#slots: " << slotCount << endl;

        if (!cplex.solve()) {
            cout<< "Fail to find a solution to the given MIP." << endl;
            throw(-1);
        }

        env.out() << "Solution status = " << cplex.getStatus(); cout << endl;
        env.out() << "Solution value  = " << cplex.getObjValue(); cout << endl;
        itr = jobList.begin();
        cout << "Solution: " << endl;
        for (j = 0; j < jobCount; j++) {
        	itr->slotPlan.clear();
        	cout << "" << itr->jobName << ": ";
        	for (t = 0; t < tSliceCount; t++) {
        		cout << IloAbs(IloRound(cplex.getValue(x[j][t]))) << " ";
        		itr->slotPlan.push_back(IloAbs(IloRound(cplex.getValue(x[j][t]))));
        	}
        	cout << endl;
        	itr++;
        }
        env.end();
        return true;
	} catch (IloException& e) {
		cout << "Concert exception caught: " << e << endl;
	} catch (...) {
		cout << "Unknown exception caught: " << endl;
	}

	env.end();
	return false;
}

